# TODO this is a perfect example of a library file. rename

# define highlight colors
export     BAD='\E[0;31m' # red
export    GOOD='\E[0;32m' # green
# define accents
export  NORMAL='\E[0m'    # reset
export    BOLD='\E[1m'    # bold
export      UL='\E[4m'    # underline
export  INVERT='\E[7m'    # invert
# define 'ls' colors
export  BROKEN='\E[1;31m' # bold red    : broken link
export     TGT='\E[1;32m' # bold green  : target
export     DIR='\E[1;34m' # bold blue   : directory
export   VALID='\E[1;36m' # bold cyan   : valid link
# define PS1 colors
export  PSTIME='\E[0;37m' # light gray  : time
export  PSUSER='\E[0;32m' # green       : user name, prompt
export  PSHOST='\E[1;34m' # bold blue   : host name
export   PSDIR='\E[0;33m' # yellow      : directory
export    PSBR='\E[0;36m' # blue        : branch
# define 'grep' colors
export     GRH='\E[1;31m' # bold red    : pattern match
export     GRF='\E[0;35m' # magenta     : file match
# define primary colors	(foreground)
export     red='\E[31m'
export   green='\E[32m'   # lime
export    blue='\E[34m'
# define secondary colors (foreground)
export  yellow='\E[33m'
export    cyan='\E[36m'  # aqua
export magenta='\E[35m'  # fuchsia
# define monochrome colors
export    gray='\E[90m'
export   white='\E[1;37m'

# subtle colors for readability
# hue=(N*30), saturation=33%, lightness=52%; sorted by hue
#      order          ID       N  hue name              corresponding color
#-----+------+--------------+----+---+-----------------+--------------------
export col08='\E[38;5;131m' #  0:   0 Indian Red        pri - RED
export col11='\E[38;5;137m' #  1:  30 Light Salmon        ter - orange
export col12='\E[38;5;143m' #  2:  60 Dark Khaki          sec - YELLOW
export col07='\E[38;5;107m' #  3:  90 Dark Olive Green    ter - chartreuse
export col03='\E[38;5;71m'  #  4: 120 Dark Sea Green    pri - GREEN/lime
export col04='\E[38;5;72m'  #  5: 150 Cadet Blue          ter - spring green
export col04='\E[38;5;73m'  #  6: 180 Cadet Blue          sec - CYAN/aqua
export col02='\E[38;5;67m'  #  7: 210 Steel Blue          ter - azure
export col01='\E[38;5;61m'  #  8: 240 Slate Blue        pri - BLUE
export col06='\E[38;5;97m'  #  9: 270 Medium Purple       ter - violet
export col10='\E[38;5;133m' # 10: 300 Medium Orchid       sec - MAGENTA/fuchsia
export col09='\E[38;5;132m' # 11: 330 Hot Pink            ter - rose

export col00='\E[38;5;102m' # 12:   0 Grey              mon - GRAY

# create rainbow-ordered (hue order) of 12 colors
declare -ax dcolor=( '\E[38;5;131m' '\E[38;5;137m' '\E[38;5;143m' '\E[38;5;107m' '\E[38;5;71m'  '\E[38;5;72m'  '\E[38;5;73m'  '\E[38;5;67m'  '\E[38;5;61m'  '\E[38;5;97m'  '\E[38;5;133m' '\E[38;5;132m' )

# reset shell options
function reset_shell() {
    if [ $# -lt 1 ]; then
        return 0
    fi

    local TAB=${TAB:='   '}
    local -r old_opts=$1
    shift
    if [ $# -lt 1 ]; then
        return 0
    fi

    decho -n "resetting shell options... "
    (        
        for opt in $@; do          
            decho
            if [[ "${opt::1}" == "+" ]]; then                
                opt=${opt:1}
            fi

            if [ $(echo ${old_opts} | grep ${opt}) ]; then
                decho "${opt} was set:${old_opts}"
                if [ $(echo $- | grep ${opt}) ]; then
                    decho -n "${opt} is set:"
                else
                    decho "${opt} is not set:$-"
                    decho -n "setting ${opt}:"
                    set -${opt}
                fi
                decho -n "$-"
            else
                decho "${opt} was not set:${old_opts}"
                if [ $(echo $- | grep ${opt}) ]; then
                    decho "${opt} is set:$-"
                    decho -n "unsetting ${opt}:"
                    set +${opt}
                else
                    decho -n "${opt} is not set:"
                fi
                decho -n "$-"
            fi
        done
        echo
    ) | sed '1d' | column -t -s':' -o': ' -R 1 | sed '1 s/^/\n/' | sed "s/^/${TAB}/"
    decho "done"
}

# print dcolor array in rainbow-order
function print_colors() {
    local -i DEBUG=1
    # add shell options if not alraedy set
    old_opts=$(echo "$-")
    set -u

    # get length of array
    local -ir N_cols=${#dcolor[@]}
    echo "$N_cols in array ${!dcolor@}"
    for ((i=0;i<$N_cols;i++));do
        echo -e "${dcolor[$i]}$i"
    done

    # reset shell options
    reset_shell ${old_opts} u
}

# print dcolor array in debug order
function print_dcolors() {
    local -i DEBUG=2
    # add shell options if not alraedy set
    old_opts=$(echo "$-")
    set -u

    # get length of array
    local -ir N_cols=${#dcolor[@]}
    echo "$N_cols in array ${!dcolor@}"
    # calculate maximum array index
    local -ir N_max=$((N_cols-1))
    echo "$N_max max index of array ${!dcolor@}"
    #---------------------------------------------------------------
    # set starting color (using array indices 0-11, specified above)
    local -ir start=7
    # set increment direction
    local -ir direction=-1
    #---------------------------------------------------------------
    echo -e "staring with index ${dcolor[$start]}${start}\x1b[m\n"
    if [ $direction -gt 0 ]; then
        echo "incrementing array indicies"
    elif [ $direction -lt 0 ]; then
        echo "decrementing array indicies"
    else
        echo "something else..."
    fi
    # declare array index variable
    local -i idx
    (
        for ((i=0;i<$N_cols;i++));do
            #define array index
            idx=$(( (${N_max} + $direction * ($i) + $start + 1 ) % ${N_cols} ))
            printf '%2d:%2d:' $i $idx

            printf "${dcolor[$idx]}%2d\x1b[m\n" $idx
        done
    ) | column -t -s: -N order,index,color

    # reset shell options
    reset_shell ${old_opts} u
}

#--------------------------------------
# define settings for dbg2idx
# Globals:
#   direction
#   idx
#   N_cols
#   N_max
#   start
# Arguments:
#   None
#--------------------------------------
function set_dbg2idx() {
    # turn in-function debugging on/off
    local -I funcDEBUG

    # get length of array
    N_cols=${#dcolor[@]}
    fecho "$N_cols elements in array ${!dcolor@}"
    # calculate maximum array index
    N_max=$((N_cols-1))
    fecho "$N_max max index of array ${!dcolor@}"
    #---------------------------------------------------------------
    # set starting color (using array indices 0-11, specified above)
    start=7
    # set increment direction
    direction=-1
    #---------------------------------------------------------------
    fecho -e "staring with index ${dcolor[$start]}${start}\x1b[m"
    if [ $direction -gt 0 ]; then
        fecho "incrementing array indicies"
    elif [ $direction -lt 0 ]; then
        fecho "decrementing array indicies"
    else
        fecho "something else..."
    fi   
}

#--------------------------------------
# convert DEBUG value to color array index
# Globals:
#   N_cols
#   N_max
#   direction
#   idx
#   start
#--------------------------------------    
function dbg2idx() {
    if [ $# -lt 1 ]; then
        >&2 echo "$FUNCNAME: input required"
        return 0
    fi

    # turn in-function debugging on/off
    local -I funcDEBUG
    
    # get input DEBUG value
    local -i dbg_in=$1
    fecho "dbg_in = $dbg_in"

    local -ir fdbg=$funcDEBUG
    funcDEBUG=0
    set_dbg2idx
    funcDEBUG=$fdbg
    
    # since DEBUG=0 does not print and DEBUG=1 corresponds to starting color, or array index 0,
    # decrement input value
    local -ir offset=-1
    local -i dbg_idx=$(( ( $dbg_in + ${offset} ) % ${N_cols} ))
    fecho "dbg_idx = $dbg_idx"
    
    #define array index
    idx=$(( ( ${N_max} + $direction * ($dbg_idx) + $start + 1 ) % ${N_cols} ))
    fecho "idx = $idx"

    fecho -e "${dcolor[$idx]}\x1b[7m${dbg_in}\x1b[m"
    
    return 0
}

# print dcolor array in debug order
function print_fcolors() {
    local -iI funcDEBUG=${funcDEBUG:-1} # inherit value or substitution default
    fecho "printing contents of dcolor..."
    local -i N_cols
    local -i N_max
    local -i start
    local -i direction

    set_dbg2idx

    local -i idx
    (
        # loop over valid non-zero values of debug
        for ((i=1;i<=$N_cols;i++));do
            #define array index
            unset idx
            dbg2idx $i
            # print indices
            printf '%2d:%2d:' $i $idx
            # print color
            printf "${dcolor[$idx]}%2d\x1b[m\n" $idx
        done
    ) | column -t -s: -N order,index,color | sed "s/^/${TAB}/"
}

function print_ls_colors() {
    # print value of LS_COLORS
    declare -p LS_COLORS |
        # isolate definitions
        sed 's/^[^"]*"//;s/"$//' |
        # print each definition on its own line
        sed '$ s/:/\n/g;/^$/d' |
        # remove file extension definitions
        sed '/^\*/d' |
        # add echo wrapper with escapes
        sed 's/\(^[^=]*\)=\(.*$\)/"\1 \\x1b[\2m\2\\x1b[m"/' |
        # echo outputs
        xargs -L 1 echo -e
}

function print_ls_colors_ext() {
    # print value of LS_COLORS
    declare -p LS_COLORS |
        # isolate definitions
        sed 's/^[^"]*"//;s/"$//' |
        # print each definition on its own line
        sed '$ s/:/\n/g;/^$/d' |
        # remove file extension definitions
        sed '/^\*/!d' |
        # add echo wrapper with escapes
        sed 's/\(^[^=]*\)=\(.*$\)/"\1 \\x1b[\2m\2\\x1b[m"/' | sort -n |
        # echo outputs
        xargs -L 1 echo -e | column -t -o ' '
}

function append_ls_colors() {
    # physical link (hardlink)
    LS_COLORS+="mh=44;38;5;15:"
    # missing
    LS_COLORS+="mi=05;48;5;232;38;5;15:"
    }
