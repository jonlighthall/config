# define highligt colors
   BAD='\E[0;31m' # red
  GOOD='\E[0;32m' # green
# define accents
NORMAL='\E[0m'    # reset
  BOLD='\E[1m'    # bold
    UL='\E[4m'    # underline
INVERT='\E[7m'    # invert
# define 'ls' colors
BROKEN='\E[1;31m' # bold red    : broken link
   TGT='\E[1;32m' # bold green  : target
   DIR='\E[1;34m' # bold blue   : directory
 VALID='\E[1;36m' # bold cyan   : valid link
# define PS1 colors
PSTIME='\E[0;37m' # light gray  : time
PSUSER='\E[0;32m' # green       : user name, prompt
PSHOST='\E[1;34m' # bold blue   : host name
 PSDIR='\E[0;33m' # yellow      : directory
  PSBR='\E[0;36m' # blue        : branch
# define 'grep' colors
   GRH='\E[1;31m' # bold red    : pattern match
   GRF='\E[0;35m' # magenta     : file match
# define primary colors	(foreground)
   red='\E[31m'
 green='\E[32m'
  blue='\E[34m'
# define secondary colors (foreground)
 yellow='\E[33m'
   cyan='\E[36m'
magenta='\E[35m'
# define monochrome colors
   gray='\E[90m'
  white='\E[1;37m'

# define horizontal line
hline() {
	if [ "$#" -lt 1 ]; then
		N=38
	else
		N=$1
	fi
	if [ "$#" -lt 2 ]; then
		m="-"
	else
		m=$2
	fi
	for ((i = 1; i <= $N; i++)); do echo -n "$m"; done
	echo
}

# define bar
bar() {
	if [ "$#" -lt 2 ]; then
		N=69
		TXT=$1
	else
		N=$1
		TXT=$2
	fi
	hline $N
	echo "$TXT"
	hline $N
}

# define centered bar print
cbar() {
	msg=$(echo " $@ ")
	# remove escape characters
	msgne=$(echo -e " $@ " | sed "s/$(echo -e "\E")[^m]*m//g")
	# get length of text
	ln=$(for ((i = 1; i <= ${#msgne}; i++)); do echo -n "-"; done)
	# print with TAB
	echo -e "$ln\n$msg\n$ln" | sed "s/^/${TAB}/"
}

# set tab
if [ -z ${TAB+dummy} ]; then
	i=0
	echo -e "TAB ${yellow}unset${NORMAL}"
	export TAB='   '
else
	i=${#TAB}
fi
j=${#TAB}
if [ $i -ne $j ]; then
	echo -e "${TAB}TAB = \E[106m${TAB}${NORMAL} length $j"
fi

function timestamp() {
	echo "$(date +"%a %b %-d at %-l:%M %p %Z")"
}

function print_elap() {
	declare -i end_time=$(date +%s%N)
	declare -i elap_time=$((${end_time} - ${start_time}))
	if command -v bc &>/dev/null; then
		dT_sec=$(bc <<<"scale=9;$elap_time/10^9" | sed 's/^\./0./')
	else
		dT_sec=${elap_time::-9}.${elap_time:$((${#elap_time}-9))}
			if [ ${#elap_time} -eq 9 ];then
				dT_sec=$(echo "0.$elap_time")
			fi
	fi
	# set scale
	declare -ir nd=3
	fmt="%.${nd}f"
	dT_sec=$(printf "$fmt" $dT_sec)	
	
	if command -v sec2elap &>/dev/null; then
		bash sec2elap $dT_sec | tr -d "\n"
	else
		echo -ne "elapsed time is ${white}${dT_sec} sec${NORMAL}"
	fi
}

function print_exit() {
	# optional argument is $?
	# e.g.
	# trap 'print_exit $?' EXIT

	# parse arguments
	if [ $# -gt 0 ]; then
		EXIT_RETVAL=$1
	fi

	start_new_line
	echo -ne "${yellow}\E[7m EXIT ${NORMAL} "
	# print exit code
	if [ ! -z ${EXIT_RETVAL+alt} ]; then
		echo -ne "${gray}RETVAL=${EXIT_RETVAL}${NORMAL} "
	fi
	echo -e "${0##*/}"
	
	print_elap
	echo -n " on "
	timestamp
}

function start_new_line() {
	# get the cursor position
	echo -en "\E[6n"
	read -sdR CURPOS
	CURPOS=${CURPOS#*[}
	# get the x-position of the cursor
	x_pos=${CURPOS#*;}
	# if the cursor is not at the start of a line, then create a new line
	if [ ${x_pos} -gt 1 ]; then
		echo
	fi
}

function print_error() {
	# expected arguments are $LINENO $? $BASH_COMMAND
	# e.g.
	# trap 'print_error $LINENO $? $BASH_COMMAND' ERR

	# parse arguments
	ERR_LINENO=$1
	shift
	ERR_RETVAL=$1
	shift
	ERR_CMD="$@"

	# print summary
	start_new_line
	ERR_PRINT=$(echo -e "\E[37;41m ERROR ${NORMAL} ")
	echo -n ${ERR_PRINT}
	# print grep-like line match
	echo -e " \E[35m${0##*/}\E[m\E[36m:\E[m\E[32m${ERR_LINENO}\E[m"

	# define indent
	declare -i spl=$(echo -ne "${ERR_PRINT}" | sed 's/\E\[[0-9;]*m//g' | wc -c)
	spc=$(echo -ne "\E[${spl}C")

	sed -n "${ERR_LINENO}p" "$src_name" | sed "s/^\s*/${spc}/"

	# if command contains vairables, evaluate expression
	if [[ "$ERR_CMD" =~ '$' ]]; then
		eva='eval '
		declare -i evl=${#eva}
		declare -i etab=$((spl - evl))
		echo -ne "\E[${etab}C${VALID}${eva}\E[m"
		eval echo $ERR_CMD
		if [[ "$ERR_CMD" =~ "/dev/null" ]]; then
			echo -e "${gray}redirect (no output)${NORMAL}"
			# remove redirect
			NCMD=$(echo $ERR_CMD | sed 's|/dev/null||')
			NCMD=$(echo $NCMD | sed 's/[12>&\s]*$//')
			# print evaluated ouput
			echo -en "\E[${spl}C"
			eval echo $NCMD
		fi		   
	fi
	echo -e "${spc}${gray}RETVAL=${ERR_RETVAL}${NORMAL}"
}

function print_int() {
	start_new_line
	echo -e "${yellow}\E[7m INT ${NORMAL} ${0##*/}"
	echo " Ctrl-C pressed"
#	echo -e "breaking..."
#	break
}

function print_return() {
	start_new_line
	echo -e "${yellow}\E[7m RETURN ${NORMAL} ${0##*/}"
}

# conditional debug echo
decho() {
	if [ -z ${DEBUG:+dummy} ] || [ $DEBUG -gt 0 ]; then
		# if DEBUG is (unset or null) or greater than 0
		echo "$@"
	fi
}

# define traps
function set_traps() {
	decho -e "${magenta}\E[7mset traps${NORMAL}"
	decho "setting shell options..."
	if (return 0 2>/dev/null); then
		decho -e "${magenta}\E[7mreturn flags${NORMAL}"
		#		set -TE +e
	else
		decho -e "${magenta}\E[7mexit flags${NORMAL}"
		set -e
	fi
	set -E
	decho "the following traps are saved"
	if [ -z "${save_traps+default}" ]; then
		decho "${fTAB}none"

		decho "setting traps..."
		trap 'print_error $LINENO $? $BASH_COMMAND' ERR
		trap 'print_exit $?' EXIT
		trap 'echo -e "${yellow}RETURN${NORMAL}: ${0##*/} $LINENO $? $BASH_COMMAND"' RETURN

	else
		decho "${save_traps}" | sed "s/^/${fTAB}/"
		decho "setting saved traps..."
		eval $(echo "${save_traps}" | sed "s/$/;/g")

		#eval $(echo '${save_traps}')
	fi
	decho "on set trap retrun, the following traps are set"
	if [ -z "$(trap -p)" ]; then
		decho "${fTAB}none"
		exit
	else
		decho $(trap -p | sed "s/^/${fTAB}/")
	fi
}

function unset_traps() {
	decho -e "${cyan}\E[7mun-set traps${NORMAL}"
	decho "setting shell options..."
	#	set +eET
	set +eE

	decho "the current traps are set"

	if [ -z "$(trap -p)" ]; then
		decho "${fTAB}none"
	else
		decho $(trap -p | sed "s/^/${fTAB}/")
		# save traps
		save_traps=$(trap -p | sed 's/-- //g')

		if [ ! -z "${save_traps}" ]; then
			decho "the current traps are saved"
			decho "${save_traps}" | sed "s/^/${fTAB}/"
		fi

		trap - ERR
		trap - EXIT
		trap - RETURN

	fi

	decho "on unset trap retrun, the following traps are set"
	if [ -z $(trap -p) ]; then
		decho "${fTAB}none"
	else
		decho $(trap -p)
		exit
	fi
}
