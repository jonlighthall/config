# define highligt colors
   BAD='\E[0;31m' # red
  GOOD='\E[0;32m' # green
# define accents
NORMAL='\E[0m'    # reset
  BOLD='\E[1m'    # bold
    UL='\E[4m'    # underline
INVERT='\E[7m'    # invert
# define 'ls' colors
BROKEN='\E[1;31m' # bold red    : broken link
   TGT='\E[1;32m' # bold green  : target
   DIR='\E[1;34m' # bold blue   : directory
 VALID='\E[1;36m' # bold cyan   : valid link
# define PS1 colors
PSTIME='\E[0;37m' # light gray  : time
PSUSER='\E[0;32m' # green       : user name, prompt
PSHOST='\E[1;34m' # bold blue   : host name
 PSDIR='\E[0;33m' # yellow      : directory
  PSBR='\E[0;36m' # blue        : branch
# define 'grep' colors
   GRH='\E[1;31m' # bold red    : pattern match
   GRF='\E[0;35m' # magenta     : file match
# define primary colors	(foreground)
   red='\E[31m'
 green='\E[32m'
  blue='\E[34m'
# define secondary colors (foreground)
 yellow='\E[33m'
   cyan='\E[36m'
magenta='\E[35m'
# define monochrome colors
   gray='\E[90m'
  white='\E[1;37m'

# define horizontal line
hline() {
	if [ "$#" -lt 1 ]; then
		N=38
	else
		N=$1
	fi
	if [ "$#" -lt 2 ]; then
		m="-"
	else
		m=$2
	fi
	for ((i = 1; i <= $N; i++)); do echo -n "$m"; done
	echo
}

# define bar
bar() {
	if [ "$#" -lt 2 ]; then
		N=69
		TXT=$1
	else
		N=$1
		TXT=$2
	fi
	hline $N
	echo "$TXT"
	hline $N
}

# define centered bar print
cbar() {
	msg=$(echo " $@ ")
	# remove escape characters
	msgne=$(echo -e " $@ " | sed "s/$(echo -e "\E")[^m]*m//g")
	# get length of text
	ln=$(for ((i = 1; i <= ${#msgne}; i++)); do echo -n "-"; done)
	# print with TAB
	echo -e "$ln\n$msg\n$ln" | sed "s/^/${TAB}/"
}

# set tab
if [ -z ${TAB+dummy} ]; then
	i=0
	echo -e "TAB ${yellow}unset${NORMAL}"
	export TAB='   '
else
	i=${#TAB}
fi
j=${#TAB}
if [ $i -ne $j ]; then
	echo -e "${TAB}TAB = \E[106m${TAB}${NORMAL} length $j"
fi

function timestamp() {
	echo "$(date +"%a %b %-d at %-l:%M %p %Z")"
}

function print_elap() {
	declare -i end_time=$(date +%s%N)
	declare -i elap_time=$((${end_time} - ${start_time}))
	if command -v bc &>/dev/null; then
		dT_sec=$(bc <<<"scale=9;$elap_time/10^9" | sed 's/^\./0./')
	else
		dT_sec=${elap_time::-9}.${elap_time:$((${#elap_time}-9))}
			if [ ${#elap_time} -eq 9 ];then
				dT_sec=$(echo "0.$elap_time")
			fi
	fi
	# set scale
	declare -ir nd=3
	fmt="%.${nd}f"
	dT_sec=$(printf "$fmt" $dT_sec)	
	
	if command -v sec2elap &>/dev/null; then
		bash sec2elap $dT_sec | tr -d "\n"
	else
		echo -ne "elapsed time is ${white}${dT_sec} sec${NORMAL}"
	fi
}

function print_exit() {
	start_new_line
	echo -e "${yellow}\E[7m EXIT ${NORMAL} ${0##*/}"
	print_elap
	echo -n " on "
	timestamp
}

function start_new_line() {
	# get the cursor position
	echo -en "\E[6n"
	read -sdR CURPOS
	CURPOS=${CURPOS#*[}
	# get the x-position of the cursor
	x_pos=${CURPOS#*;}
	# if the cursor is not at the start of a line, then create a new line
	if [ ${x_pos} -gt 1 ]; then
		echo
	fi
}

function print_error() {
	# expected arguments are $LINENO $? $BASH_COMMAND
	# e.g.
	# trap 'print_error $LINENO $? $BASH_COMMAND' ERR

	# parse arguments
	ERR_LINENO=$1
	shift
	ERR_RETVAL=$1
	shift
	ERR_CMD="$@"

	# print summary
	start_new_line
	ERR_PRINT=$(echo -e "\E[37;41m ERROR ${NORMAL} ")
	echo -n ${ERR_PRINT}
	# print grep-like line match
	echo -e " \E[35m${0##*/}\E[m\E[36m:\E[m\E[32m${ERR_LINENO}\E[m"

	# define indent
	declare -i spl=$(echo -ne "${ERR_PRINT}" | sed 's/\E\[[0-9;]*m//g' | wc -c)
	spc=$(echo -ne "\E[${spl}C")

	sed -n "${ERR_LINENO}p" "$src_name" | sed "s/^\s*/${spc}/"

	# if command contains vairables, evaluate expression
	if [[ "$ERR_CMD" =~ '$' ]]; then
		eva='eval '
		declare -i evl=${#eva}
		declare -i etab=$((spl - evl))
		echo -ne "\E[${etab}C${VALID}${eva}\E[m"
		eval echo $ERR_CMD
		if [[ "$ERR_CMD" =~ "/dev/null" ]]; then
			echo -e "${gray}redirect (no output)${NORMAL}"
			# remove redirect
			NCMD=$(echo $ERR_CMD | sed 's|/dev/null||')
			NCMD=$(echo $NCMD | sed 's/[12>&\s]*$//')
			# print evaluated ouput
			echo -en "\E[${spl}C"
			eval echo $NCMD
		fi		   
	fi
	echo -e "${spc}${gray}RETVAL=${ERR_RETVAL}${NORMAL}"
}

function print_int() {
	start_new_line
	echo -e "${yellow}\E[7m INT ${NORMAL} ${0##*/}"
	echo " Ctrl-C pressed"
#	echo -e "breaking..."
#	break
}

function print_return() {
	start_new_line
	echo -e "${yellow}\E[7m RETURN ${NORMAL} ${0##*/}"
}
