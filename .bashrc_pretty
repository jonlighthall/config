#!/bin/bash -u

# get canonical source name
src_name=$(readlink -f ${BASH_SOURCE[0]})

# get source path
## physical (canonical)
src_dir_phys=$(dirname $src_name)
## logical (links)
src_dir_logi=$(dirname $BASH_SOURCE)

# determine if script is being sourced or executed and add conditional behavior
if (return 0 2>/dev/null); then
    RUN_TYPE="sourcing"
else
    RUN_TYPE="executing"
    # exit on errors
    set -e
    # print note
fi

# print run type and source name
echo -e "${TAB}${RUN_TYPE} ${PSDIR}$BASH_SOURCE${NORMAL}..."
src_name=$(readlink -f $BASH_SOURCE)
if [ ! "$BASH_SOURCE" = "$src_name" ]; then
    echo -e "${TAB}${VALID}link${NORMAL} -> $src_name"
fi

# print source path
## physical
echo -e "${TAB}${gray}phys -> $src_dir_phys${NORMAL}"
## logical
echo -e "${TAB}${gray}logi -> $src_dir_logi${NORMAL}"

# load bash utils
for util in .bash_colors .bash_tabs .bash_links; do
    # use the canonical (physical) source directory for reference; this is important if sourcing
    # this file directly from shell
    fname="${src_dir_phys}/${util}"
    if [ -e "${fname}" ]; then
        source ${fname}
    else
        echo "${fname} not found"
    fi
done

# set debug level
declare -i DEBUG=${DEBUG:=0} # default value if DEBUG is unset or null


function fello() {
    hello
    return 0
    
}



# print function stack
function print_stack() {


    ddecho "BASH_ARGC = $BASH_ARGC"
    ddecho "BASH_ARGV = $BASH_ARGV"
    ddecho "BASH_COMMAND = $BASH_COMMAND"
    ddecho "BASH_SUBSHELL = $BASH_SUBSHELL"
    
    # get length of stack
    local -i NB=${#BASH_SOURCE[@]}
    ddecho "${TAB}There are N=$NB entries in the call stack"

    ddecho "${TAB}full bash source:"
    ddecho "${TAB}${fTAB}BASH_SOURCE[@] = ${BASH_SOURCE[@]}"

    ddecho "${TAB}this source:"
    ddecho "${TAB}${fTAB}BASH_SOURCE[0] = ${BASH_SOURCE[0]}"

    if [ $NB -gt 1 ]; then
        ddecho "${TAB}invoking source source:"
        itab
        ddecho "${TAB}BASH_SOURCE[1] = ${BASH_SOURCE[1]##*/}"
        ddecho "${TAB}BASH_SOURCE[(($NB-1))] = ${BASH_SOURCE[$NB-1]##*/}"
        dtab
    fi

    local -i NF=${#FUNCNAME[@]}
    ddecho "${TAB}There are N=$NF entries in the execution call stack"
    ddecho "${TAB}FUNCNAME=${FUNCNAME[@]}"

    ddecho "${TAB}call stack:"
    itab
    # (
    #     for ((i = 0; i < $NF; i++)); do
    #         ddecho -n "${TAB}$i: ${FUNCNAME[$i]} "
    #         ddecho -n ":defined in: ${BASH_SOURCE[$i]##*/} "
    #         ddecho -n ":called by: "
    #         if [ -z "${BASH_SOURCE[$i+1]}" ]; then
    #             ddecho -n "NULL " 
    #         else
    #             ddecho -n "${BASH_SOURCE[$i+1]##*/} "
    #         fi
    #         ddecho ":on line: ${BASH_LINENO[$i]}"
    #     done
    # ) | column -t -s : -o ""
    dtab
    
    if [ ${#FUNCNAME[@]} -gt 1 ]; then
        ddecho "${TAB}FUNCNAME[$((NF-2))]=${FUNCNAME[$((NF-2))]}"
    fi

    local -i NL=${#BASH_LINENO[@]}
    ddecho "${TAB}There are N=$NL entries in the line number stack"
    ddecho "${TAB}line no stack:"
    itab
    for ((i = 0; i < $NL; i++)); do
        ddecho "${TAB}$i: line ${BASH_LINENO[$i]}"
    done    
    dtab
    ddecho "lineno $LINENO"

    # get size of function stack
    local -ir n_func=${#FUNCNAME[@]}

    # fecho() should only be called from other functions, so the length of FUNCNAME
    # should always be 2 or greater. Start with color 0
    local -ir idx=$(( n_func - 2 ))    
    
    # set color
    echo -ne "${dcolor[idx]}"

    local -i x
    local -i start
    local -i stop

    # define function stack printing limits
    if [[ ${FUNCNAME[1]} == "xecho" ]]; then
        # xecho
        start=$(( $n_func - 2 ))
        stop=2
    else
        # function
        start=$(( $n_func - 5 ))
        stop=0
    fi

    # print size of function stack
    echo -ne "$n_func"

    # print debug type
    if [[ ${FUNCNAME[1]} == "xecho" ]]; then
        # xecho
        echo -ne "x"
    else
        # function
        echo -ne "f"
    fi

    echo -n ": ${#FUNCNAME[@]} functions, ${#BASH_SOURCE[@]} sources, ${#BASH_LINENO[@]} lines"

    echo

    if [[ ${FUNCNAME[$n_func]} == "main"  ]]; then
        echo "main"
    fi

    for func in ${FUNCNAME[@]}; do
        echo $func
    done

    for (( i=0; i<$n_func; i++ )); do 
        echo "$i ${FUNCNAME[i]} defined in $(basename ${BASH_SOURCE[i]}) on line ${BASH_LINENO[i]}; and called from $(basename ${BASH_SOURCE[i+1]})"
    done

    # print contents of function stack...
    echo -en "["                
    for (( x=(( $n_func - 0 )); x>-1; x-- )); do
        if [[ ${FUNCNAME[x]} == "xecho" ]]; then
            break
        fi
        echo -en "$(basename ${BASH_SOURCE[x+1]} 2>/dev/null) ${BASH_LINENO[x]}: ${FUNCNAME[x]}\e[0m${dcolor[idx]} -> "
    done
    echo -en "$(basename ${BASH_SOURCE[x]}) ${BASH_LINENO[x]}] "
    
    echo
    
    # print contents of function stack...
    echo -en "["
    for (( x=$start; x>$stop; x-- )); do
        echo -en "$(basename ${BASH_SOURCE[x+1]}) ${BASH_LINENO[x]}: ${FUNCNAME[x]}\e[0m${dcolor[idx]} -> "
    done
    echo -en "$(basename ${BASH_SOURCE[x]}) ${BASH_LINENO[x]}] "

}

# conditional debug echos

# define in-function debug echo
function fecho() {
    # NAME
    #   fecho - function echo
    # DESCRIPTION
    #   echos arguments based on the value of funcDEBUG in calling function
    #   NB: only define funcDEBUG as a local variable within FUNCTIONS

    # check if funcDEBUG is defined
    if [ ! -z ${funcDEBUG:+dummy} ]; then       
        # check if $funcDEBUG is non-zero
        if [ $funcDEBUG -gt 0 ]; then
            # get size of function stack
            local -ir n_func=${#FUNCNAME[@]}

            # fecho() should only be called from other functions, so the length of FUNCNAME
            # should always be 2 or greater. Start with color 0
            local -ir idx=$(( n_func - 2 ))    
            
            # set color
            echo -ne "${dcolor[idx]}"

            # define function stack printing
            local -i fidx
            if [[ ${FUNCNAME[1]} == "xecho" ]]; then
                fidx=2
            else
                fidx=$(( $n_func - 5 ))
            fi            
            echo -ne "${FUNCNAME[fidx]}\e[0m${dcolor[idx]}: "
            echo "$@"
            echo -ne "\e[0m"
        fi
    fi
    return 0
}

# start a new line only if not already on a new line
# i.e., carriage return with conditional line feed
function start_new_line() {
    # get the cursor position
    echo -en "\E[6n"
    read -sdR CURPOS
    local CURPOS=${CURPOS#*[}
          #}# dummy bracket for emacs indenting
    # get the x-position of the cursor
    local -i x_pos=${CURPOS#*;}
    # if the cursor is not at the start of a line, then create a new line
    if [ ${x_pos} -gt 1 ]; then
        printf '\e[0;90;40m\u21b5\n\e[m'
        #echo
    fi
}

# define debug echos

# generic debug message handler
# the debugging functions should be named as follows
#   decho - level 1: informative... or print steps
#  ddecho - level 2: explicitly print values
# dddecho - level 3: why...?
# and so on
function xecho() {
    # check for null or empty arguments ...to skip coloring?
    if false; then
        if [ $# -eq 0 ] ; then
            echo "no args"
        else
            echo "number of args: $#"
        fi
        
        if [[ -z "$@" ]]; then
            echo "empty"
        else
            echo "args: $@"
        fi
    fi
    
    # turn in-function debugging on/off
    local -iI funcDEBUG=${funcDEBUG:-1} # inherit value or substitution default

    # use function name to specify debug threshold
    local fu=${FUNCNAME[1]}
    fecho "FUNCNAME = $fu"
    local pre=${fu%echo}
    fecho "prefix = $pre"
    local -ir ln=${#pre}
    fecho "length = $ln"
    local -ir thr=$(( ln - 1 ))
    fecho "threshold = $thr"
    fecho "DEBUG = $DEBUG"
    fecho -e "args = \e[7m$@\e[m"

    # if DEBUG is (unset or null) or greater than threshold
    if [ -z ${DEBUG:+dummy} ] || [ $DEBUG -gt $thr ]; then
        # get color index
        local -i idx
        fecho "loading color index $ln..."
        dbg2idx $ln
        fecho "printing..."
        # set color
        echo -ne "${dcolor[$idx]}"
        # print message
        echo "$@"
        # unset color
        echo -ne "\e[0m"
        if [ $funcDEBUG -gt 0 ]; then
            start_new_line
        fi
        
    else
        fecho "not printing"
    fi
    return 0
}

# define debug echo
function decho() {
    xecho "$@"
    return 0
}

function ddecho() {
    xecho "$@"    
    return 0
}

decho "DEBUG = $DEBUG"

# If not running interactively, reduce prints
if [[ "$-" == *i* ]]; then
    itab
    msg=$(echo "this file is ${src_name##*/}!")
    ln=$(for ((i = 1; i <= ${#msg}; i++)); do echo -n "-"; done)
    echo -e "$ln\n$msg\n$ln" | sed "s/^/${TAB}/"
    # add read-only variable to check if this file has already been loaded
    if [ -z ${fpretty_loaded+dummy} ]; then
        declare -grx fpretty_loaded=true
    else
        echo -e "${TAB}${yellow}${BASH_SOURCE[0]##*/} already loaded${NORMAL}"
    fi
    dtab
fi

# print horizontal line
function hline() {
    # SYNTAX
    #   hline [length] [style]
    
    # number of characters in line (length)
    local -i N
    if [ "$#" -lt 1 ]; then
        N=38
    else
        N=$1
    fi
    # marker used to create line (style)
    local m
    if [ "$#" -lt 2 ]; then
        m="-"
    else
        m=$2
    fi
    for ((i = 1; i <= $N; i++)); do echo -n "$m"; done
    echo
}

# print text between two bars
function bar() {
    # SYNTAX
    #   bar [length] [text]

    # number of characters in line (length)
    local -i N
    # text to print between bars
    local TXT
    if [ "$#" -lt 2 ]; then
        N=69
        TXT=$1
    else
        N=$1
        TXT=$2
    fi
    hline $N
    echo "$TXT"
    hline $N
}

# define centered bar print
function cbar() {
    # SYNTAX
    #   cbar [text]

    # get text and add whitespace
    local msg=$(echo " $@ ")
    # remove escape characters
    local msgne=$(echo -e " $@ " | sed "s/$(echo -e "\E")[^m]*m//g")
    # get length of text
    local ln=$(for ((i = 1; i <= ${#msgne}; i++)); do echo -n "-"; done)
    # print text with TAB
    echo -e "$ln\n$msg\n$ln" | sed "s/^/${TAB}/"
}

# print source name, elapsed time, and timestamp
function print_done() {
    # set local debug value
    local DEBUG=${DEBUG:=0}  # default value if DEBUG is unset or null

    # get length of stack
    local -i N=${#BASH_SOURCE[@]}
    ddecho "${TAB}There are N=$N entries in the call stack"

    ddecho "${TAB}full bash source:"
    ddecho "${TAB}${fTAB}BASH_SOURCE[@] = ${BASH_SOURCE[@]}"

    ddecho "${TAB}this source:"
    ddecho "${TAB}${fTAB}BASH_SOURCE[0] = ${BASH_SOURCE[0]}"

    if [ $N -gt 1 ]; then
        ddecho "${TAB}invoking source source:"
        ddecho "${TAB}${fTAB}BASH_SOURCE[1] = ${BASH_SOURCE[1]}"
    fi

    echo -en "${BASH_SOURCE[(($N - 1))]##*/}${NORMAL} "
    print_elap
    echo -n " on "
    timestamp
}

# format timestamp
function timestamp() {
    echo "$(date +"%a %b %-d at %-l:%M %p %Z")"
}

# print elapsed time
function print_elap() {
    # get current time (end time)
    local -i end_time=$(date +%s%N)

    # check if start time is defined
    if [ -n "${start_time+alt}" ]; then
        # calculate interval (in ns)
        local -i elap_time=$((${end_time} - ${start_time}))
        # convert to seconds
        local dT_sec
        if command -v bc &>/dev/null; then
            dT_sec=$(bc <<<"scale=9;$elap_time/10^9" | sed 's/^\./0./')
        else
            dT_sec=${elap_time::-9}.${elap_time:$((${#elap_time} - 9))}
            if [ ${#elap_time} -eq 9 ]; then
                dT_sec=$(echo "0.$elap_time")
            fi
        fi
        # set precision
        local -ir nd=3
        # format interval
        local fmt="%.${nd}f"
        dT_sec=$(printf "$fmt" $dT_sec)

        # print output
        if command -v sec2elap &>/dev/null; then
            bash sec2elap $dT_sec | tr -d "\n"
        else
            echo -ne "elapsed time is ${white}${dT_sec} sec${NORMAL}"
        fi
    else
        decho -ne "${yellow}start_time not defined${NORMAL} "
        # reset cursor position for print_done, etc.
        echo -en "\x1b[1D"
    fi
}

function print_exit() {
    # optional argument is $?
    # e.g.
    # trap 'print_exit $?' EXIT

    # parse arguments
    if [ $# -gt 0 ]; then
        local EXIT_RETVAL=$1
    fi

    start_new_line
    echo -ne "${TAB}${yellow}\E[7m EXIT ${NORMAL} "
    # print exit code
    if [ ! -z ${EXIT_RETVAL+alt} ]; then
        echo -ne "${gray}RETVAL=${EXIT_RETVAL}${NORMAL} "
    fi

    print_done
}

function print_error() {
    # expected arguments are $LINENO $? $BASH_COMMAND
    # e.g.
    # trap 'print_error $LINENO $? $BASH_COMMAND' ERR

    # parse arguments
    local -i ERR_LINENO=$1
    shift
    local -i ERR_RETVAL=$1
    shift
    local ERR_CMD="$@"

    # print summary
    start_new_line
    local ERR_PRINT=$(echo -e "${TAB}\E[37;41m ERROR ${NORMAL} ")
    echo -n ${ERR_PRINT}
    # print grep-like line match
    echo -ne " \E[35m${BASH_SOURCE[1]##*/}\E[m\E[36m:\E[m\E[32m${ERR_LINENO}\E[m\E[36m:\E[m"

    # get the cursor position
    echo -en "\E[6n"
    read -sdR CURPOS
    local CURPOS=${CURPOS#*[}
          #}# dummy bracket for emacs indenting
    # get the x-position of the cursor
    local -i x_pos=${CURPOS#*;}
    ((--x_pos))
    ((--x_pos))
    # define indent
    local spx=$(echo -ne "\E[${x_pos}C")

    local ERR_LINE=$(sed -n "${ERR_LINENO}p" "${BASH_SOURCE[1]}" | sed "s/^\s*//")
    echo "${ERR_LINE}"
    eva='eval'
    local -i evl=${#eva}
    local -i etab=$((x_pos - evl))

    if [[ "$ERR_CMD" != "$ERR_LINE" ]]; then
        echo -ne "\E[${etab}C${yellow} cmd\E[36m:\E[m"
        echo "${ERR_CMD}"
    fi

    # if command contains vairables, evaluate expression
    if [[ "$ERR_CMD" =~ '$' ]]; then
        decho -e "${spx} ${gray}expanding variables...${NORMAL}"
        # print 'eval' set back from cmd
        echo -ne "\E[${etab}C${VALID}${eva}\E[m\E[36m:\E[m"
        # print evaluated command and remove leading whitespace
        eval echo $ERR_CMD | sed "s/^\s*//"
        if [[ "$ERR_CMD" =~ "/dev/null" ]]; then
            # remove redirect
            NCMD=$(echo $ERR_CMD | sed 's|/dev/null||')
            NCMD=$(echo $NCMD | sed 's/[12>&\s]*$//')
            # print evaluated ouput
            echo -en "\E[${spx}C"
            eval echo $NCMD
            echo -e "$ {gray}redirect (no output)${NORMAL}"
        fi
    fi
    echo -e "${spx} ${gray}RETVAL=${ERR_RETVAL}${NORMAL}"
}

function print_int() {
    start_new_line
    echo -e "${yellow}\E[7m INT ${NORMAL} ${BASH_SOURCE[1]##*/}"
    echo " Ctrl-C pressed"
    #	echo -e "breaking..."
    #	break
}

function print_return() {
    # set local debug value
    local DEBUG=${DEBUG:=0}  # default value if DEBUG is unset or null

    # set shell options
    decho "setting shell options..."
    # trace ERR (inherit ERR trap from shell)
    #set -E
    # trace RETURN and DEBUG traps
    #set -T
    decho "done"

    RETURN_RETVAL=$1
    
    start_new_line


    # get size of function stack
    local -ir n_func=${#FUNCNAME[@]}
    
    echo -e "${yellow}\E[7m RETURN ${NORMAL} ${gray}RETVAL=${RETURN_RETVAL}${NORMAL} ${FUNCNAME[$((n_func-2))]}"
}

# define traps
function set_traps() {
    # set local debug value
    local DEBUG=${DEBUG:=0} # default value if DEBUG is unset or null

    [ $DEBUG -gt 0 ] && start_new_line
    decho -e "${magenta}\E[7mset traps${NORMAL}"

    # set shell options
    decho -n "setting shell options..."
    # exit on errors
    set -e
    # trace ERR (inherit ERR trap from shell)
    #set -E
    # trace RETURN and DEBUG traps
    #set -T
    decho "done"
    
    ddecho "the following traps are saved"
    if [ -z "${save_traps+default}" ]; then
        ddecho "${fTAB}none"
        ddecho -n "setting traps... "
        trap 'print_error $LINENO $? $BASH_COMMAND' ERR
        trap 'print_exit $?' EXIT
        ddecho "done"
    else
        ddecho "${save_traps}" | sed "$ ! s/^/${fTAB}/"
        ddecho "setting saved traps..."
        eval $(echo "${save_traps}" | sed "s/$/;/g")
    fi

    # print summary
    ddecho -n "on set trap retrun, the following traps are set"
    if [ -z "$(trap -p)" ]; then
        ddecho -e "\n${fTAB}none"
        exit
    else
        ddecho
        ddecho $(trap -p) | sed "$ ! s/^/${fTAB}/;s/ \(trap\)/\n${fTAB}\1/g" | sed 's/^[ ]*$//g'
    fi
}

function unset_traps() {
    # set local debug value
    local DEBUG=${DEBUG:=0} # default value if DEBUG is unset or null

    [ $DEBUG -gt 0 ] && start_new_line
    decho -e "${cyan}\E[7mun-set traps${NORMAL}"

    # set shell options
    decho -n "setting shell options... "
    # trace ERR (inherit ERR trap from shell)
    set -E
    # trace RETURN and DEBUG traps
    #set -T
    # DO NOT exit on errors
    set +e
    #    set +eE
    decho "done"

    ddecho -n "the current traps are set"
    if [ -z "$(trap -p)" ]; then
        ddecho -e "\n${fTAB}none"
    else
        ddecho
        ddecho $(trap -p) | sed "$ ! s/^/${fTAB}/;s/ \(trap\)/\n${fTAB}\1/g" | sed 's/^[ ]*$//g'

        # save traps
        export save_traps=$(trap -p | sed 's/-- //g')
        if [ ! -z "${save_traps}" ]; then
            ddecho "the current traps are saved"
            ddecho "${save_traps}" | sed "$ ! s/^/${fTAB}/"
        fi

        # clear traps
        trap - ERR
        trap - EXIT
        trap - RETURN
    fi

    # print summary
    ddecho "on unset trap retrun, the following traps are set"
    if [ -z $(trap -p) ]; then
        ddecho "${fTAB}none"
    else
        ddecho $(trap -p)
        exit
    fi
}
