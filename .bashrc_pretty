# define highligt colors
   BAD='\033[0;31m' # red
  GOOD='\033[0;32m' # green
# define accents
NORMAL='\033[0m'    # reset
  BOLD='\033[1m'    # bold
    UL='\033[4m'    # underline
# define 'ls' colors
BROKEN='\033[1;31m' # bold red    : broken link
   TGT='\033[1;32m' # bold green  : target
   DIR='\033[1;34m' # bold blue   : directory
 VALID='\033[1;36m' # bold cyan   : valid link
# define PS1 colors
PSTIME='\033[0;37m' # light gray  : time
PSUSER='\033[0;32m' # green       : user name, prompt
PSHOST='\033[1;34m' # bold blue   : host name
 PSDIR='\033[0;33m' # yellow      : directory
  PSBR='\033[0;36m' # blue        : branch
# define 'grep' colors
   GRH='\033[1;31m' # bold red    : pattern match
   GRF='\033[0;35m' # magenta     : file match
# define primary colors	(foreground)
   red='\033[31m'
 green='\033[32m'
  blue='\033[34m'
# define secondary colors (foreground)
 yellow='\033[33m'
   cyan='\033[36m'
magenta='\033[35m'
# define monochrome colors
   gray='\x1B[90m'
  white='\x1B[1;37m'

# define horizontal line
hline() {
	if [ "$#" -lt 1 ]; then
		N=38
	else
		N=$1
	fi
	if [ "$#" -lt 2 ]; then
		m="-"
	else
		m=$2
	fi
	for ((i = 1; i <= $N; i++)); do echo -n "$m"; done
	echo
}

# define bar
bar() {
	if [ "$#" -lt 2 ]; then
		N=69
		TXT=$1
	else
		N=$1
		TXT=$2
	fi
	hline $N
	echo "$TXT"
	hline $N
}

# define centered bar print
cbar() {
	msg=$(echo " $@ ")
	msgne=$(echo -e " $@ " | sed "s/$(echo -e "\x1B")[^m]*m//g")
	ln=$(for ((i = 1; i <= ${#msgne}; i++)); do echo -n "-"; done)
	echo -e "$ln\n$msg\n$ln" | sed "s/^/${TAB}/"
}

# set tab
if [ -z ${TAB+dummy} ]; then
	i=0
	echo -e "TAB ${yellow}unset${NORMAL}"
	export TAB='   '
else
	i=${#TAB}
fi
j=${#TAB}
if [ $i -ne $j ]; then
	echo -e "${TAB}TAB = \x1B[106m${TAB}${NORMAL} length $j"
fi

function timestamp() {
	echo "$(date +"%a %b %-d at %-l:%M %p %Z")"
}

function print_elap() {
	declare -i end_time=$(date +%s%N)
	declare -i elap_time=$((${end_time} - ${start_time}))
	if command -v bc &>/dev/null; then
		dT_sec=$(bc <<<"scale=3;$elap_time/1000000000")
	else
		dT_sec=${elap_time::-9}
	fi
	if command -v sec2elap &>/dev/null; then
		bash sec2elap $dT_sec | tr -d "\n"
	else
		echo -n "elapsed time is ${white}${dT_sec} sec${NORMAL}"
	fi
}

function print_exit() {
	start_new_line
	echo -e "${yellow}\E[7m EXIT ${NORMAL} ${0##*/}"
	print_elap
	echo -n " on "
	timestamp
}

function start_new_line() {
	# get the cursor position
	echo -en "\E[6n"
	read -sdR CURPOS
	CURPOS=${CURPOS#*[}
	# get the x-position of the cursor
	x_pos=${CURPOS#*;}
	# if the cursor is not at the start of a line, then create a new line
	if [ ${x_pos} -gt 1 ]; then
		echo
	fi
}

function print_error() {
	# expected arguments are $LINENO $? $BASH_COMMAND
	# e.g.
	# trap 'print_error $LINENO $? $BASH_COMMAND' ERR

	# parse arguments
	ERR_LINENO=$1
	shift
	ERR_RETVAL=$1
	shift
	ERR_CMD="$@"

	# print summary
	start_new_line
	ERR_PRINT=$(echo -e "\E[37;41m ERROR ${NORMAL} ")
	echo -n ${ERR_PRINT}
	# print grep-like line match
	echo -e " \E[35m${0##*/}\E[m\E[36m:\E[m\x1B[32m${ERR_LINENO}\x1B[m"

	# define indent
	declare -i spl=$(echo -ne "${ERR_PRINT}" | sed 's/\x1b\[[0-9;]*m//g' | wc -c)
	spc=$(echo -ne "\x1B[${spl}C")

	sed -n "${ERR_LINENO}p" $src_name | sed "s/^\s*/${spc}/"

	# if command contains vairables, evaluate expression
	if [[ "$ERR_CMD" =~ '$' ]]; then
		eva='eval '
		declare -i evl=${#eva}
		declare -i etab=$((spl - evl))
		echo -ne "\x1B[${etab}C${VALID}${eva}\E[m"
		eval echo $ERR_CMD
	fi
	echo -e "${spc}${gray}RETVAL=${ERR_RETVAL}${NORMAL}"
}

function print_int() {
	start_new_line
	echo -e "${yellow}\E[7m INT ${NORMAL} ${0##*/}"
	echo " Ctrl-C pressed"
#	echo -e "breaking..."
#	break
}

function print_return() {
	start_new_line
	echo -e "${yellow}\E[7m RETURN ${NORMAL} ${0##*/}"
}
