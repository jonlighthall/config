#!/bin/bash -eu
# -----------------------------------------------------------------------------------------------
#
# ~/config/.bashrc_pretty
#
# Purpose: define and load advanced functions for interactive shell sessions, including
#   "pretty-print" formatting
#
# Apr 2023 JCL
#
# -----------------------------------------------------------------------------------------------

# add read-only variable to check if this file has already been loaded
if [ ! -z ${FPRETTY_LOADED+dummy} ]; then      
    if [ ! -z "$(declare -f print_pretty_cbar)" ]; then 
        decho "${TAB}${BASH_SOURCE##*/} already loaded"
        return 0
    fi
fi    

# set debug level
declare -i DEBUG=${DEBUG:=0} # assign default value if DEBUG is unset or null

# If running interactively, print source
if [[ "$-" == *i* ]] && [ ${DEBUG:-0} -gt 0 ]; then
    echo -e "${TAB:=$(for ((i = 1; i < ${#BASH_SOURCE[@]}; i++)); do echo -n "   "; done)}\E[2m${#BASH_SOURCE[@]}: ${BASH_SOURCE##*/} -> $(readlink -f ${BASH_SOURCE})\E[22m"
fi

function get_source() {
    # get the length of the execution stack
    N_BASH=${#BASH_SOURCE[@]}
    # since this function is part of the stack, reduce N_BASH by one
    ((N_BASH--))
    # check stack size
    if [ $N_BASH -lt 1 ]; then
        return 0
    fi

    # define function level
    local -i FUNC_LEV
    # check if calling function is print*
    if [[ "${FUNCNAME[1]}" =~ "print"* ]]; then
        if [ $N_BASH -lt 2 ]; then
            return 0
        fi
        FUNC_LEV=2
    else
        FUNC_LEV=1
    fi   
    
    # get canonical source name
    src_name=$(readlink -f ${BASH_SOURCE[${FUNC_LEV}]})
    # get short source name
    src_base=$(basename "${src_name}")
    # get source path
    ## physical (canonical)
    src_dir_phys=$(dirname "$src_name")
    ## logical (links)
    src_dir_logi=$(dirname "${BASH_SOURCE[${FUNC_LEV}]}")
}

function load_libs() {
    if command -v decho &>/dev/null; then
        # print function name 
        decho -e "${TAB}${INVERT}${FUNCNAME}${RESET}"
        itab
    fi
    get_source
    # load bash utils
    local fname
    local library

    for library in links \
                       traps\
                       tabs \
                       cond_echo \
                       fmt \
                       colors \
                       stack \
                       dbg
    do
        # use the canonical (physical) source directory for reference; this is important if sourcing
        # this file directly from shell
        fname="${src_dir_phys}/lib_${library}.sh"
        if [ -e "${fname}" ]; then
            if [[ "$-" == *i* ]] && [ ${DEBUG:-0} -gt 0 ]; then
                echo "${TAB}loading $(basename ${fname})"
            fi
            source ${fname}
        else
            echo "${fname} not found"
        fi
    done
    if [ ! -z ${FPRETTY_LOADED+dummy} ]; then      
        dtab # lib tabs
        cbar "libraries loaded" # lib_fmt
        if [ $DEBUG -gt 1 ]; then
            lecho # lib_dbg
            print_ribbon #lib_stack
            print_return # lib_traps
        fi
    fi
}

load_libs

# determine if script is being sourced or executed and add conditional behavior
if (return 0 2>/dev/null); then
    :
else
    # exit on errors
    set -e
fi

# check if running interactively
if [[ "$-" == *i* ]]; then
    #set tab
    set_tab
    decho "${TAB}${BASH_SOURCE##*/}: DEBUG = $DEBUG"
    #print_ribbon
    #print_bar

    # determine if script is being sourced or executed
    if (return 0 2>/dev/null); then
        RUN_TYPE="sourcing"
    else
        RUN_TYPE="executing"
    fi
    print_source
fi

if [[ "$-" == *i* ]] && [ ${DEBUG:-0} -gt 0 ]; then
    print_pretty_cbar
fi

declare -grx FPRETTY_LOADED=true
